# TurboLoader v0.3.0 Design Document

**Author**: Software Engineering Team
**Date**: 2025-01-15
**Status**: Design Phase
**Target Release**: v0.3.0

---

## Executive Summary

Version 0.3.0 introduces three major feature sets:
1. **WebDataset Iterator API** - Python iterator interface for seamless integration
2. **Multi-format Image Support** - PNG and WebP decoders
3. **Augmentation Operations** - Rotation, color jitter, and other transforms

These features maintain TurboLoader's performance-first philosophy while improving usability and flexibility.

---

## 1. WebDataset Iterator API

### 1.1 Design Goals

- **Pythonic Interface**: Support `for batch in loader:` syntax
- **Backwards Compatibility**: Keep existing Pipeline API
- **Zero Copy**: Maintain performance characteristics
- **Flexibility**: Support various iteration patterns (epochs, samples, batches)

### 1.2 Architecture

```
┌─────────────────────────────────────────────────────────┐
│                  Python Iterator Layer                   │
│  ┌────────────────────┐    ┌────────────────────────┐  │
│  │ WebDatasetLoader   │───▶│  IteratorAdapter       │  │
│  └────────────────────┘    └────────────────────────┘  │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│              Existing Pipeline (C++)                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │  Reader  │─▶│  Queue   │─▶│  Output  │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└─────────────────────────────────────────────────────────┘
```

### 1.3 API Design

```python
# New Iterator API
from turboloader import WebDatasetLoader

# Create loader
loader = WebDatasetLoader(
    urls=['imagenet-{000000..001281}.tar'],
    batch_size=256,
    num_workers=8,
    shuffle=True,
    transforms=[...],
    collate_fn=default_collate
)

# Iterate
for epoch in range(100):
    for batch in loader:
        images, labels = batch['image'], batch['label']
        # Training code...
```

### 1.4 Implementation Plan

**Phase 1: Iterator Wrapper (Week 1)**
- Create `WebDatasetLoader` class in Python
- Wrap existing `Pipeline` with iterator protocol
- Implement `__iter__()` and `__next__()`
- Handle epoch boundaries and reset

**Phase 2: Batching & Collation (Week 1)**
- Implement flexible batch assembly
- Add custom collate function support
- Handle variable-length sequences
- Integrate with existing queue system

**Phase 3: Shuffling & Sampling (Week 2)**
- Implement deterministic shuffling
- Add distributed sampling support
- Support weighted sampling
- Add infinite iterator mode

### 1.5 Key Classes

```python
class WebDatasetLoader:
    """PyTorch-style DataLoader for WebDataset format"""

    def __init__(self, urls, batch_size, num_workers, ...):
        self.pipeline = Pipeline(urls, config)
        self.batch_size = batch_size
        self.epoch = 0

    def __iter__(self):
        """Reset and return iterator"""
        self.pipeline.reset()
        return self

    def __next__(self):
        """Get next batch"""
        batch = self.pipeline.next_batch(self.batch_size)
        if len(batch) == 0:
            raise StopIteration
        return self._collate(batch)

    def __len__(self):
        """Total number of batches"""
        return self.pipeline.total_samples() // self.batch_size
```

---

## 2. Multi-Format Image Support

### 2.1 Design Goals

- **Format Agnostic**: Support JPEG, PNG, WebP seamlessly
- **Performance**: Match JPEG decoder speed where possible
- **Extensibility**: Easy to add new formats (BMP, TIFF, etc.)
- **Auto-detection**: Determine format from magic bytes

### 2.2 Architecture

```
┌─────────────────────────────────────────────────────────┐
│              Image Decoder Registry                      │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐   │
│  │  JPEG   │  │   PNG   │  │  WebP   │  │  Auto   │   │
│  │ Decoder │  │ Decoder │  │ Decoder │  │ Detect  │   │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘   │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│              Common Decoder Interface                    │
│                                                           │
│  virtual DecodedImage decode(const uint8_t* data,       │
│                               size_t len) = 0;           │
└─────────────────────────────────────────────────────────┘
```

### 2.3 Format Support

| Format | Library | SIMD Support | Priority |
|--------|---------|--------------|----------|
| **JPEG** | libjpeg-turbo | ✅ (existing) | Complete |
| **PNG** | libpng + stb_image | ⚠️ (limited) | High |
| **WebP** | libwebp | ✅ (SSE2/NEON) | High |
| BMP | stb_image | ❌ | Low |
| TIFF | libtiff | ❌ | Future |

### 2.4 Implementation Plan

**Phase 1: PNG Decoder (Week 2)**
- Integrate libpng for lossless PNG
- Use stb_image as fallback (header-only)
- Add PNG detection (magic bytes: `89 50 4E 47`)
- Implement thread-local decoders
- Add tests with real PNG images

**Phase 2: WebP Decoder (Week 2)**
- Integrate libwebp library
- Enable SIMD optimizations (SSE2/NEON)
- Add WebP detection (magic bytes: `RIFF...WEBP`)
- Support both lossy and lossless WebP
- Benchmark against other formats

**Phase 3: Auto-detection (Week 3)**
- Implement magic byte detection
- Create format registry
- Add fallback mechanisms
- Performance optimization (avoid extra copies)

### 2.5 Key Classes

```cpp
// Base decoder interface
class ImageDecoder {
public:
    virtual ~ImageDecoder() = default;

    virtual DecodedImage decode(
        const uint8_t* data,
        size_t len
    ) = 0;

    virtual bool can_decode(
        const uint8_t* data,
        size_t len
    ) const = 0;
};

// PNG decoder
class PngDecoder : public ImageDecoder {
private:
    // Thread-local PNG structures
    thread_local static png_structp png_ptr_;
    thread_local static png_infop info_ptr_;

public:
    DecodedImage decode(const uint8_t* data, size_t len) override;
    bool can_decode(const uint8_t* data, size_t len) const override;
};

// WebP decoder
class WebPDecoder : public ImageDecoder {
public:
    DecodedImage decode(const uint8_t* data, size_t len) override;
    bool can_decode(const uint8_t* data, size_t len) const override;

private:
    // WebP decode with SIMD
    DecodedImage decode_simd(const uint8_t* data, size_t len);
};

// Auto-detecting decoder
class AutoDecoder {
public:
    DecodedImage decode(const uint8_t* data, size_t len);

private:
    std::vector<std::unique_ptr<ImageDecoder>> decoders_;
    ImageDecoder* detect_format(const uint8_t* data, size_t len);
};
```

---

## 3. Augmentation Operations

### 3.1 Design Goals

- **SIMD Optimized**: Use AVX2/NEON for all operations
- **Composable**: Chain multiple augmentations
- **Deterministic**: Reproducible with random seed
- **GPU Ready**: Prepare for future GPU acceleration

### 3.2 Augmentation Catalog

| Operation | Description | SIMD | Complexity |
|-----------|-------------|------|------------|
| **Rotation** | Rotate by arbitrary angle | ✅ | Medium |
| **Color Jitter** | Random brightness/contrast/saturation | ✅ | Low |
| **Random Crop** | Extract random region | ❌ | Low |
| **Horizontal Flip** | Mirror horizontally | ✅ | Low |
| **Vertical Flip** | Mirror vertically | ✅ | Low |
| **Gaussian Blur** | Blur with Gaussian kernel | ✅ | High |
| **Random Erasing** | Erase random rectangles | ❌ | Low |

### 3.3 Architecture

```
┌─────────────────────────────────────────────────────────┐
│            Augmentation Pipeline                         │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐           │
│  │ Transform │─▶│ Transform │─▶│ Transform │           │
│  │     1     │  │     2     │  │     3     │           │
│  └───────────┘  └───────────┘  └───────────┘           │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│              SIMD Operation Layer                        │
│  ┌─────────────────────────────────────────────────┐   │
│  │  AVX2/AVX-512 (x86_64) | NEON (ARM)             │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 3.4 Implementation Plan

**Phase 1: Core Infrastructure (Week 3)**
- Define `AugmentationTransform` interface
- Implement transform composition
- Add random number generator (thread-safe)
- Create augmentation registry

**Phase 2: Basic Augmentations (Week 3-4)**
- Horizontal/Vertical Flip (SIMD optimized)
- Random Crop (cache-friendly)
- Color Jitter (SIMD brightness/contrast)

**Phase 3: Advanced Augmentations (Week 4)**
- Rotation (bilinear interpolation, SIMD)
- Gaussian Blur (separable filter, SIMD)
- Random Erasing

### 3.5 Key Classes

```cpp
// Base augmentation transform
class AugmentationTransform {
public:
    virtual ~AugmentationTransform() = default;

    virtual void apply(
        uint8_t* data,
        int width,
        int height,
        int channels,
        std::mt19937& rng  // Thread-local RNG
    ) = 0;

    virtual void set_params(const TransformParams& params) = 0;
};

// Color jitter (SIMD optimized)
class ColorJitterTransform : public AugmentationTransform {
public:
    void apply(uint8_t* data, int w, int h, int c, std::mt19937& rng) override;

    void set_brightness_range(float min, float max);
    void set_contrast_range(float min, float max);
    void set_saturation_range(float min, float max);

private:
    // SIMD implementations
    void apply_brightness_avx2(uint8_t* data, size_t n, float factor);
    void apply_contrast_avx2(uint8_t* data, size_t n, float factor);
    void apply_saturation_neon(uint8_t* data, size_t n, float factor);

    float brightness_min_, brightness_max_;
    float contrast_min_, contrast_max_;
    float saturation_min_, saturation_max_;
};

// Rotation (bilinear, SIMD)
class RotationTransform : public AugmentationTransform {
public:
    void apply(uint8_t* data, int w, int h, int c, std::mt19937& rng) override;

    void set_angle_range(float min_degrees, float max_degrees);
    void set_fill_color(uint8_t r, uint8_t g, uint8_t b);

private:
    // SIMD bilinear interpolation
    void rotate_bilinear_avx2(
        const uint8_t* src, uint8_t* dst,
        int w, int h, int c, float angle
    );

    float min_angle_, max_angle_;
    uint8_t fill_color_[3];
};

// Composable pipeline
class AugmentationPipeline {
public:
    void add_transform(std::unique_ptr<AugmentationTransform> transform);

    void apply_all(uint8_t* data, int w, int h, int c);

    void set_seed(uint64_t seed);

private:
    std::vector<std::unique_ptr<AugmentationTransform>> transforms_;
    std::mt19937 rng_;  // Thread-local RNG
};
```

---

## 4. Integration & Testing

### 4.1 Python Bindings

```python
# WebDataset Iterator
loader = WebDatasetLoader(
    urls=['data-{000..999}.tar'],
    batch_size=256,
    transforms=[
        turboloader.RandomHorizontalFlip(p=0.5),
        turboloader.ColorJitter(
            brightness=0.2,
            contrast=0.2,
            saturation=0.2
        ),
        turboloader.RandomRotation(degrees=15),
        turboloader.Resize(224, 224),
        turboloader.Normalize(mean=[0.485, 0.456, 0.406])
    ],
    supported_formats=['jpg', 'png', 'webp']
)

for batch in loader:
    # Training...
    pass
```

### 4.2 Testing Strategy

**Unit Tests**:
- PNG decoder with various bit depths (8, 16, 24, 32)
- WebP decoder (lossy, lossless, alpha)
- Each augmentation transform
- Format auto-detection

**Integration Tests**:
- End-to-end pipeline with multiple formats
- Augmentation composition
- Iterator protocol compliance

**Performance Tests**:
- Decoder benchmarks (PNG vs JPEG vs WebP)
- Augmentation overhead measurement
- Memory usage profiling

### 4.3 Benchmarks

Target performance metrics:
- PNG decode: 1000-2000 img/s (vs 5000+ for JPEG)
- WebP decode: 2000-3000 img/s
- Augmentation overhead: <10% slowdown
- Memory: No additional allocations per sample

---

## 5. Dependencies

### 5.1 New Dependencies

```cmake
# PNG support
find_package(PNG REQUIRED)

# WebP support
find_package(WebP REQUIRED)

# Optional: stb_image (header-only fallback)
# No package needed, include directly
```

### 5.2 Build Configuration

```cmake
option(TURBOLOADER_WITH_PNG "Enable PNG support" ON)
option(TURBOLOADER_WITH_WEBP "Enable WebP support" ON)
option(TURBOLOADER_WITH_STB "Use stb_image fallback" OFF)
```

---

## 6. Migration Path

### 6.1 Backwards Compatibility

Existing code continues to work:
```python
# Old API (still supported)
pipeline = turboloader.Pipeline(['data.tar'], config)
pipeline.start()
batch = pipeline.next_batch(256)
```

### 6.2 Deprecation Timeline

- v0.3.0: Introduce new APIs
- v0.4.0-v0.9.0: Both APIs supported
- v1.0.0: Consider deprecating old API

---

## 7. Timeline

**Week 1: WebDataset Iterator**
- Mon-Tue: Iterator wrapper implementation
- Wed-Thu: Batching & collation
- Fri: Testing & debugging

**Week 2: Image Formats**
- Mon-Tue: PNG decoder
- Wed-Thu: WebP decoder
- Fri: Auto-detection & tests

**Week 3: Augmentations Part 1**
- Mon: Core infrastructure
- Tue-Wed: Basic augmentations (flip, crop, jitter)
- Thu-Fri: Testing & optimization

**Week 4: Augmentations Part 2 & Polish**
- Mon-Tue: Advanced augmentations (rotation, blur)
- Wed: Integration testing
- Thu: Documentation
- Fri: Release preparation

---

## 8. Success Criteria

- ✅ WebDataset iterator matches PyTorch DataLoader API
- ✅ PNG/WebP decode within 2x of JPEG speed
- ✅ Augmentations add <10% overhead
- ✅ All tests pass (unit, integration, performance)
- ✅ Documentation complete with examples
- ✅ No performance regression on existing features

---

## 9. Risks & Mitigations

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| PNG decode too slow | High | Medium | Use stb_image fallback, optimize |
| SIMD complexity | Medium | High | Start with scalar, add SIMD incrementally |
| API confusion | Medium | Medium | Clear docs, examples, migration guide |
| Memory overhead | High | Low | Profile early, optimize allocations |

---

## 10. Future Work (v0.4.0+)

- GPU-accelerated augmentations
- Additional formats (TIFF, BMP, HEIF)
- Advanced augmentations (MixUp, CutMix)
- TensorFlow/JAX bindings
- Cloud storage backends

---

**Status**: Design Complete ✅
**Next**: Begin implementation (Week 1)
